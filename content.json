{"posts":[{"title":"About Me","text":"[ğŸ”¨ Pinned] I am currently a Ph.D. student at Hong Kong University of Science and Technology (HKUST), under the guidance of Prof.Charles Zhang. My current research interests focus on program analysis and theorectial computer science. Before that, I received my bachelorâ€™s degree in computer science from Shanghai Jiao Tong University. During my undergraduate study, I worked closely with the following professors: Biaoshuai Tao, Hongfei Fu, Qinxiang Cao and Yuhao Zhang. Thanks for their patient guidance. contact: jsongbk@cse.ust.hk [Google Scholar] | [Publication] | [Blogs] | [Github] Research Interests My research interests include static program static analysis and theoretical computer science problems. More recenltly, I have been studying problems in: Large-scaled Language Model (LLM) for static analysis Scalable static analysis tool Development Loop Invariant Generation Selected Awards Hong Kong PhD Fellowship Scheme (2023) Zhiyuan Outstanding Student Scholarship in SJTU (2023) [link]","link":"/2023/02/03/About-Me/"},{"title":"Reading List of Jiaxin","text":"I will maintain a list of blogs or official document interesting to me here. 1. LLVM Kaleidoscope: Implementing a Language with LLVM Writting a LLVM Pass How to Parse LLVM IR Line by Line? 2. Program Analysis Linear Invariant Generation Non-linear loop invariant generation using GrÃ¶bner bases [POPLâ€™04] [link] In this paper, the authors propose an method to generate polynomial loop invariants. The invariant problem eta(l) /\\ theta |= eta(l') can be also regarded as determining whether eta(l') \\in Ideal(eta(l), theta). They use some heuristic methods based on the GrÃ¶bner bases. For example, they introduce new parameter \\lambda and determine whether \\lambda*NF(eta(l)) = NF(eta(l')). A Singular Introduction to Commutative Algebra [link], especially, sec 1.7 Strong Grobner Bases for Polynomials over a Prinpal Ideal Ring [link] New developments in the theory of Groebner bases and applications to formal verification [link] Accerlating Program Analysis Split input: Input Splitting for Cloud-Based Static Application Security Testing Platforms (ICSEâ€™ 22) Constraint Solving z3 playground z3 rust, z3 rust crate api Program Analysis of Rust Rust Lifetime [link] Visualization of Lifetime Constraints in Rust [link] C2Rust: Ownership Analysis [link] SPrinter: A Static Checker for Finding Smart Pointer Errors in C++ Programs [link] Detecting Memory-Related Bugs by Tracking Heap Memory Management of C++ Smart Pointers [link] Translating C to Safer Rust (OOPSLAâ€™21) [link] 3. Fair Division Group Fairness Kneser graph: Discrepency theory: Almost Envy-Freeness for Groups: Improved Bounds via Discrepancy Theory Minimize the number of queries when calculating fair allocations Fairly Allocating Many Goods with Few Queries The Query Complexity of Cake Cutting Almost envy-free allocations with connected bundles 4. Blockchain Gas Cost Bound Analysis Developing Cost-Effective Blockchain-Powered Applications: A Case Study of the Gas Usage of Smart Contract Transactions in the Ethereum Blockchain Platform Data-Driven Loop Bound Learning for Termination Analysis Computing Exact Loop Bounds for Bounded Program Verification Exact and Linear-Time Gas-Cost Analysis","link":"/2023/02/13/Useful-Documents-and-Blogs/"},{"title":"Paper Reading: Goshawk","text":"This is a paper reading report of the paper â€œGoshawk: Hunting Memory Corruptions via Structure-Aware and Object-Centric Memory Operation Synopsisâ€ in S&amp;Pâ€™2022. They mainly study how to detect the memory management function (MM) (e.g., malloc(), free(), kzmalloc()). They found most of the memory management functions can be determined according to their function name and propose a new approach to identify MM functions with the help of a trained NLP model. 1. Motivation Why we need to identify the MM functions? In Figure 1, the authors provide a motivated example, where there is a double-free bug caused by user-defined memory management functions. In function hvfb_probe(), it invokes function hvfb_getmem(), which could free the pointer info-&gt;apertures. However, it ignores this fact and frees this pointer again later. For a static analysis tool, for example, KLEE, it just knows free() and kfree() are deallocators. So when encountering the call of function hvfb_getmem(), it does not know that function could potentially free the pointer info-&gt;apertures. It will go into that function and then continue searching â€¦, and finally encounter the call of kfree(). Such analysis is time-consuming. If we are able to know hvfb_getmem() may frees info-&gt;apertures, we could have skipped unfolding hvfb_getmem(). 2. Overview of the paper The above figure gives an overview of this paper: Given the C source codes and the prototypes of all the functions, they use a pre-trained NLP model ($\\tau:$ function name $\\rightarrow [0, 1]$) to determine whether a function is an allocator/deallocator or not. The higher of the value of $\\tau(f)$, the higher the probability $f$ is an allocator/deallocator. Set the threshold as $\\theta$. Next, the functions with a higher belief than $\\theta$ will be included in the set of MM candidate. Next, suppose the input official MM functions $\\mathcal{M}$ = {free, malloc, kmalloc, $\\ldots$}. The authors design a data-flow analysis algorithm to validate whether a candidate is an MM function. Finally, they provide a Memory Operation Synopsis(MOS) for verified MM function. The MOS is an MM behaviors summary. With the help of these summaries, they further do some bug detection. 3. Advantages and Disadvantages 4. Implementation Details To determine whether a MM function candidate is an real MM function. The authors design a data-flow based algorithm. After reading their implementation, I summarize their algorithm for detecting allocators as follows: Denote the call graph as $G = (V, E)$, where $V$ contains all the methods and $E$ contains all the call-edges. Specially, $(f,g)\\in E$ if method $f$ calls method $g$. For an method $f$, we use $\\mathcal{A}(f)$ to represent the set of its callees. Perform the NLP model and get a belief $\\tau(f) \\in [0,1]$ for each method $f$ of $V$. Set the threshold as $\\theta$ and collect the set of methods with a belief no more than $\\theta$: $\\mathcal{C} \\triangleq$ ${f: \\tau(f) \\ge \\theta}$. Extract a subset of methods $\\mathcal{S}$ from $\\mathcal{C}$. These functions satisfy the following requirements and are named strong belief allocation functions. For each method $f\\in \\mathcal{S}$, the return type of $f$ is a pointer, there is no pointer within the parameters of $f$, $\\tau(f) \\ge \\theta$, Exact one of its callees must belongs to $\\mathcal{S}$, If the return type is a struct pointer, then $f$ should not have more than two callees belonging to $\\mathcal{S}$. In addition, they also include the official allocators into the set $\\mathcal{S}$. Although these requirements look a litte weirdâ€¦, I get they want to first pick some candidates that have high probabilities to be MM functions. Next, for the all candidates of $\\mathcal{C}$, they perform the following check: [Check 1]: Check whether a candidate $f$ invokes a strong belief allocation function of $\\mathcal{S}$. Otherwise or $f\\in \\mathcal{S}$, kick $f$ off from $\\mathcal{C}$. [Check 2]: For a candidate $f$, if it directly invokes a strong belief allocation function $g$ of $\\mathcal{S}$, then go to the third check. Otherwise, recursively traverse all of its callees and perform the second check. If one of its callees is included in $\\mathcal{S}$, then further perform the third check. [Check 3]: Denote the call of $g$ within $f$ by ret &lt;- g(...). If $ret$ occurs in the return values, then include $f$ into $\\mathcal{S}$. Otherwise, check wether $ret$ occurs in the parameters of $f$ (it means $f$ return the allocated memory via passing parameters).","link":"/2023/09/03/Paper-Reading-Goshawk/"},{"title":"SSA Transformation of Move Stackless Bytecodes","text":"æœ€è¿‘åœ¨åšæœ‰å…³Move Proverçš„å¼€å‘ã€‚è¿™ä¸¤å‘¨ä¸»è¦è´Ÿè´£å°†Move Stackless Bytecodeè½¬æ¢ä¸ºsingle staic assignment(SSA)æ ¼å¼ã€‚æƒ³ç®€å•å†™ä¸€ç¯‡æ–‡ç« è®°å½•ä¸€ä¸‹å…·ä½“å®ç°æµç¨‹ã€‚ 1. Source Codes SSAæºä»£ç å¯ä»¥åœ¨forkå‡ºçš„repoé‡Œæœ€æ–°çš„ä¸¤ä¸ªcommitè·å–ã€‚ Usage 1$ move prove -p [move dir] -- -ssa #enable ssa transformation Example: 1234IfConditionâ”œâ”€â”€ Move.tomlâ””â”€â”€ sources â””â”€â”€ main.move å…¶ä¸­main.moveçš„å†…å®¹å¦‚ä¸‹ï¼š 1234567891011module 0xCAFE::BasicCoin { public fun f1(x1: u8) :u8 {x1} public fun if1(x1: u8, i: u8) :u8 { if (i &gt; 0) { x1 = 1; }; f1(x1) }} æ‰§è¡Œ 1$ move prove -p IfCondition -- -dump-bytecode å¯ä»¥çœ‹åˆ°åŸå§‹çš„bytecodeå¦‚ä¸‹: 123456789101112131415161718192021public fun BasicCoin::if1($t0|x1: u8, $t1|i: u8): u8 { var $t2: u8 var $t3: u8 var $t4: bool var $t5: u8 var $t6: u8 var $t7: u8 0: $t2 := move($t1) 1: $t3 := 0 2: $t4 := &gt;($t2, $t3) 3: if ($t4) goto 4 else goto 8 4: label L1 5: $t5 := 1 6: $t0 := $t5 7: goto 8 8: label L0 9: $t6 := move($t0) 10: $t7 := BasicCoin::f1($t6) 11: return $t7} æ‰§è¡Œ 12$ move prove -p IfConidtion -- -ssa è¾“å‡ºçš„ç»ssaè½¬æ¢åçš„bytecodeå¦‚ä¸‹ï¼š 12345678910111213141516171819202122public fun BasicCoin::if1($t0|x1: u8, $t1|i: u8): u8 { var $t2: u8 var $t3: u8 var $t4: bool var $t5: u8 var $t6: u8 var $t7: u8 var $t8: u8 var $t9: u8 0: $t2 := move($t1) 1: $t3 := 0 2: $t4 := &gt;($t2, $t3) 3: if ($t4) goto 4 else goto 7 4: label L1 5: $t5 := 1 6: $t9 := $t5 7: label L0 8: $t8 := phi($t0, $t9) 9: $t6 := move($t8) 10: $t7 := BasicCoin::f1($t6) 11: return $t7} 2. Main Algorithm ä¸»è¦çš„ç®—æ³•å®ç°å‚è€ƒäº† [1] ä¸­åŸºäºdominatorçš„SSA constructionç®—æ³•ã€‚å¤§è‡´æµç¨‹åˆ†ä¸ºä¸¤æ­¥ï¼š (Phi Insertion): å…ˆè®¡ç®—å‡ºæ§åˆ¶æµå›¾ä¸­éœ€è¦æ’å…¥Phiå‡½æ•°çš„ä½ç½®ã€‚ (Variable Renaming): å¯¹æºä»£ç ä¸­å®šä¹‰å’Œä½¿ç”¨çš„å˜é‡åšé‡å‘½åã€‚ 3. Implementation ç›®å‰move-proveråœ¨stackless bytecodeè¿™ä¸ªé˜¶æ®µè¿›è¡Œçš„åˆ†æï¼Œéƒ½æ˜¯ä»¥FunctionProcessorçš„å½¢å¼ç»™ä¸Šå±‚è°ƒç”¨æä¾›æ¥å£ã€‚å…¶ä¸­FunctionProcessor::Process()æ–¹æ³•ï¼Œåœ¨æ‹¿åˆ°æ‰€æœ‰å‡½æ•°çš„signatureï¼Œç¯å¢ƒä¿¡æ¯ï¼Œä»¥åŠæŸä¸ªå…·ä½“å¾…åˆ†æå‡½æ•°çš„å…·ä½“å†…å®¹åï¼Œå¯¹å¾…åˆ†æçš„å‡½æ•°å†…å®¹åšä¸€äº›å˜æ¢/åˆ†æã€‚ move-prover/src/bytecode/src/function_target_pipeline.rs12345678910111213pub trait FunctionTargetProcessor { /// Processes a function variant. Takes as parameter a target holder which can be mutated, the /// env of the function being processed, and the target data. During the time the processor is /// called, the target data is removed from the holder, and added back once transformation /// has finished. This allows the processor to take ownership on the target data. fn process( &amp;self, _targets: &amp;mut FunctionTargetsHolder, _fun_env: &amp;FunctionEnv&lt;'_&gt;, _data: FunctionData, ) -&gt; FunctionData { unimplemented!() } å‡ºäºä¸move-proveråç«¯ä»£ç å¼€å‘ä¿æŒä¸€è‡´ï¼Œå¹¶ä¸”èƒ½è®©å¯¼å‡ºçš„SSA codeså¯ä»¥ç”¨ä¸Šç›®å‰å·²æœ‰çš„åˆ†æçš„ç›®çš„ï¼Œæˆ‘å°†SSAè½¬åŒ–ä¹Ÿå®ç°åœ¨äº†FunctionTargetProcessorå†…ã€‚ä½†å…¶å®æ³¨æ„åˆ°ï¼Œprocessçš„è¿”å›å€¼åªæ˜¯åŸæœ¬çš„dataï¼Œè¿™æ˜¯å› ä¸ºï¼Œç»è¿‡SSAè½¬æ¢åçš„bytecodeå’ŒåŸæœ¬çš„bytecodeå…¶å®æ˜¯ä¸¤å¥—ï¼Œç›®å‰è¿˜ä¸ç¡®å®šä¼šä¸ä¼šå½±å“ä¸€äº›built-inçš„analysisçš„æ­£å¸¸æ‰§è¡Œã€‚æ‰€ä»¥åœ¨è¿™é‡Œåªæ˜¯æŠŠè½¬æ¢åçš„ç»“æœæ‰“å°å‡ºæ¥äº†ï¼Œå¹¶æ²¡æœ‰å®é™…è¿”å›ã€‚ move-prover/src/bytecode/src/ssa_analysis.rs1234567891011121314151617impl FunctionTargetProcessor for SSAConstructionProcessor { fn process( &amp;self, _targets: &amp;mut FunctionTargetsHolder, func_env: &amp;FunctionEnv, data: FunctionData, ) -&gt; FunctionData { let original_data = data.clone(); let mut define_once_vars: Vec&lt;TempIndex&gt; = vec![]; let data_with_phi = Self::insert_phi_functions(data, func_env, &amp;mut define_once_vars); let data_after_renaming = Self::rename_variables(data_with_phi, func_env, &amp;mut define_once_vars); let func_target = FunctionTarget::new(func_env, &amp;data_after_renaming); println!(&quot;{}&quot;, format!(&quot;{func_target}&quot;)); original_data } 3.1 Add Phi() to the Definition of Bytecodes SSAå’ŒåŸå§‹bytecodeçš„ä¸»è¦åŒºåˆ«åœ¨äºPhiå‡½æ•°çš„å¼•å…¥ã€‚æˆ‘åœ¨åŸå§‹bytecodeçš„å®šä¹‰ä¸­ï¼ŒåŠ å…¥äº†ä¸€æ¡$v_s = \\phi\\left( [v_{t,1}, \\ldots, v_{t, k}], v\\right)$ã€‚å…¶ä¸­$v_s$è¡¨ç¤ºç”±$\\phi$å‡½æ•°å®šä¹‰çš„æ–°å¯„å­˜å™¨ç¼–å·ï¼Œ$[v_{t,1}, \\ldots, v_{t, k}]$è¡¨ç¤ºåœ¨æ­¤å¤„åˆå¹¶çš„æ‰€æœ‰å˜é‡å®šä¹‰ï¼Œ$v$è¡¨ç¤ºè¿™äº›æ–°å˜é‡åœ¨åŸå§‹bytecodeä¸­å¯¹åº”çš„ä¸‹æ ‡ã€‚ move-prover/src/bytecode/src/sackless_bytecode.rs123456pub enum Bytecode { Assign(AttrId, TempIndex, TempIndex, AssignKind), ... Phi(AttrId, TempIndex, Vec&lt;TempIndex&gt;, TempIndex), // New added} Note: å®é™…ä¸Šï¼Œå°½ç®¡bytecodeä¸­ç›®å‰æ·»åŠ äº†phiè¿™æ¡è¯­å¥ï¼Œåœ¨å…¶ä»–åˆ†æä¸­ä»ç„¶ç”¨çš„æ˜¯æ—§çš„bytecodeã€‚å³ä½¿åœ¨è¯­æ³•ä¸Šä¸å¾—ä¸å¤„ç†phiï¼Œä¹Ÿéƒ½é‡‡å–è·³è¿‡çš„åŠæ³•ã€‚ 3.2 Graph Algorithm API ç›®å‰åœ¨mover-proveré‡Œï¼Œæä¾›äº†ä¸¤ç§ç‰ˆæœ¬çš„å›¾ç®—æ³•ï¼Œä¸€ç§æ˜¯move-prover/src/bytecode/src/graph.rså†…æä¾›çš„ä¸€äº›generalçš„å›¾ç®—æ³•çš„å®ç°ï¼ˆdominatorè®¡ç®—ï¼Œimmediate dominance treeçš„æ„å»ºï¼‰ï¼Œå¦å¤–ä¸€ç§æ˜¯åœ¨move-prover/src/bytecode/src/stackless_control_flow_graph.rså†…æä¾›äº†ä¸€äº›control flow graphä¸Šçš„ç®—æ³•ï¼ˆå¦‚ä½•ä»çº¿æ€§çš„bytecodeè½¬æˆcontrol flow graphï¼Œå¦‚ä½•æ‰“å°ç­‰ç­‰ï¼‰ã€‚ åœ¨æ‹¿åˆ°ä¸€ä¸ªStacklessControlFlowGraphåï¼Œå¦‚æœæƒ³åœ¨ä¸Šé¢è·‘ä¸€äº›å›¾ç®—æ³•ï¼Œéœ€è¦å…ˆå°†å…¶è½¬ä¸ºä¸€ä¸ªgraphï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š move-prover/src/bytecode/src/ssa_analysis.rs123456789101112131415fn create_graph_from_cfg(cfg: &amp;StacklessControlFlowGraph) -&gt; Graph&lt;BlockId&gt; { let entry: BlockId = cfg.entry_block(); let nodes: Vec&lt;BlockId&gt; = cfg.blocks(); let edges: Vec&lt;(BlockId, BlockId)&gt; = nodes .iter() .flat_map(|x| { cfg.successors(*x) .iter() .map(|y| (*x, *y)) .collect::&lt;Vec&lt;(BlockId, BlockId)&gt;&gt;() }) .collect(); let graph = Graph::new(entry, nodes, edges); graph} å’Œdominatorç›¸å…³çš„è®¡ç®—éƒ½å®ç°åœ¨move-prover/src/bytecode/src/graph.rsçš„DomRelationå†…ã€‚å®ƒåœ¨æ‹¿åˆ°ä¸€ä¸ªå›¾ä¹‹åï¼Œå¯¹ç»“ç‚¹è¿›è¡Œé‡æ–°ç¼–å·ã€‚å…·ä½“æ¥è¯´ï¼Œå‡å¦‚è¾“å…¥çš„å›¾çš„æ‰€æœ‰ç»“ç‚¹ä¸º$[a, b, c]$ï¼ŒDomRelationä¼šå†…éƒ¨ç»´æŠ¤ä¸€ä¸ªæ˜ å°„ï¼Œå°†$[a, b, c]$æ˜ å°„åˆ°$[0, 1, 2]$ã€‚å…¶ä¸­ä¸»è¦ç”¨åˆ°çš„APIæ¥å£çš„ä»‹ç»å¦‚ä¸‹ï¼š pub fn is_dominated_by(&amp;self, x: T, y: T) -&gt; bool åˆ¤æ–­ç»“ç‚¹xæ˜¯å¦è¢«ç»“ç‚¹yæ‰€dominateã€‚ pub fn postorder_visit(&amp;mut self, graph: &amp;Graph&lt;T&gt;) å¯¹è¾“å…¥çš„å›¾åšåç»­éå†ï¼Œå¹¶åˆå§‹åŒ–å†…éƒ¨ç»´æŠ¤çš„æ˜ å°„ã€‚ pub fn depth_first_traverse(&amp;self, graph: &amp;Graph&lt;T&gt;) -&gt; Vec&lt;T&gt; å¯¹immediate dominante treeåšæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œå¹¶è¿”å›éå†ç»“æœã€‚ pub fn compute_dominance_frontier(&amp;mut self, graph: &amp;Graph&lt;T&gt;) è®¡ç®—æ‰€æœ‰ç»“ç‚¹å¯¹åº”çš„dominance frontierã€‚ 3.3 Phi Insertion Phi insertionçš„ä¸»è¦å®ç°å¤§è‡´å¦‚ä¸‹ï¼š å…ˆå–å‡ºåŸå§‹çš„data: FunctionDataå†…çš„æ‰€æœ‰bytecodeï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„control flow graphï¼Œ 1234let old_code = std::mem::take(&amp;mut builder.data.code);let cfg = StacklessControlFlowGraph::new_forward(&amp;old_code);let graph = Self::create_graph_from_cfg(&amp;cfg);let dom_frontier = graph.compute_dominance_frontier(); æ‰§è¡Œ[1]ä¸­çš„Phi insertionç®—æ³•ï¼Œè®¡ç®—å‡ºæ‰€æœ‰éœ€è¦æ’å…¥Phiçš„ä½ç½®åœ¨bytecodeä¸­çš„offset é€å¥éå†bytecodeï¼Œå¹¶ä¸€æ¡ä¸€æ¡emitåˆ°dataå†…ï¼Œ 12345678910111213for (offset, bc) in old_code.into_iter().enumerate() { let co_offset = offset as CodeOffset; if phi_insertion_records.contains_key(&amp;co_offset) { builder.emit(bc); let variable_vec = phi_insertion_records.get_mut(&amp;co_offset).unwrap(); for v in variable_vec { let new_attrid = builder.new_attr(); builder.emit(Bytecode::Phi(new_attrid, v.clone(), vec![], v.clone())) } } else { builder.emit(bc); }} 3.4 Variable Renaming Variable renamingçš„ä¸»è¦å®ç°å¤§è‡´å¦‚ä¸‹ï¼š å…ˆå–å‡ºåŸå§‹çš„data: FunctionDataå†…çš„æ‰€æœ‰bytecodeï¼Œå¹¶ç”Ÿæˆå¯¹åº”çš„control flow graphã€‚ åˆå§‹åŒ–æ¯ä¸ªå¯„å­˜å™¨çš„reaching definitionï¼Œ 123456for i in 0..parameter_count { reaching_def_map.insert(i, (i, cfg.entry_block()));}for i in parameter_count..local_count { reaching_def_map.insert(i, (usize::MAX, cfg.entry_block()));} DFSéå†immediate dominance treeï¼Œå¹¶å¯¹æ¯ä¸ªblockå†…çš„æŒ‡ä»¤åšrenaming, 123456789101112let dom_tree_dfs_res = dom_relation.depth_first_traverse(&amp;graph);for block_id in dom_tree_dfs_res { Self::rename_variables_within_block( &amp;mut builder, &amp;mut old_code, &amp;dom_relation, &amp;mut reaching_def_map, &amp;cfg, &amp;block_id, define_once_vars, );} 4. Limitation ç›®å‰è™½ç„¶å®ç°é‡Œï¼Œç»è¿‡SSAè½¬åŒ–ä¹‹åï¼Œå¾—åˆ°çš„å½¢å¼æ˜¯FunctionDataçš„æ ¼å¼ã€‚ä½†ç›®å‰è¿˜æ²¡æœ‰ç»è¿‡æµ‹è¯•ï¼Œçœ‹æ˜¯å¦å’Œå…¶ä»–åˆ†æå…¼å®¹ã€‚ åœ¨SSAè½¬åŒ–è¿‡ç¨‹ä¸­ï¼Œå¹¶æ²¡æœ‰å¤„ç†Prop Reference [1]. Sec 3. SSA book.","link":"/2023/04/17/SSA-Transformation-of-Move-Stackless-Bytecodes/"},{"title":"Infer Buffer Overrun (II) - Abstract Domain","text":"Abstract In this blog, we will take a further look at the abstract domain within the buffer overrun checker (inferbo), including intervals, bounds, locations, and memory model. Inferbo uses the conventional program analysis techinque of intervals for the range of index values and buffer sizes. Infers works on the intervals [low, high], where the two bounds are both symbolic [1]. Moreover, the bounds can also contain some linear arithmetic with min/max operators. 1. Bound Here is the formal definition of bound within inferbo. It is implemented in the file infer/src/bufferoverrun/bounds.ml. $$ \\mathbf{LinearSym} \\triangleq \\mathbf{Sym} \\rightarrow \\mathbb{Z} $$ $$ \\mathbf{Bound} \\triangleq \\pm \\infty \\ |\\ \\mathbb{Z} + \\mathbf{LinearSym} \\ |\\ \\mathbb{Z} +\\max/\\min(\\mathbb{Z}, \\mathbf{LinearSym}) $$ $$ |\\ \\min/\\max(\\mathbf{Bound}, \\mathbf{Bound})\\ |\\ \\mathbb{Z} + \\mathbf{Bound} \\times \\mathbf{Bound}, $$ where $\\mathbf{Sym}$ represents symbols (e.g., variables occurred in the program), and $\\mathbf{LinearSym}$ represents a linear composition of symbols. Within the module Bound, infer also offers some tool functions. Among them, pp specifies the output format; of_big_int converts an int number n to Linear n; is_symbolic determines whether there is a symbol within a bound; le gives an rough comparation between two bounds. However, it only defines orders for only straightforward cases. For some comparation like $1+ x \\overset{?}{&lt;} 1+ y$, it can not determine the result and just return false; neg takes a bound to be negative; exact_min computes the exact minimum value of two bounds. For example, $\\mathrm{exact\\ min}(c1, c2 + x) = \\min(c2, \\min(c2 - c1, x))$. underapprox_min gives a lower bound of the minimum value of two bounds; overapprox_min gives an upper bound of the minimum value of two bounds; plus_u (plus_l) sums two bounds as upper bounds (lower bounds); 2. Interval The interval is defined in the module ItvPure of the file infer/src/bufferoverrun/itv.ml. Each interval is composed of a lower bound lb and an upper bound ub. 3. Memory Model Similar to the heap model in separation logic, the memory within infer buffer overrun checker is modeled as $\\mathbf{Mem}: \\mathbf{Loc} \\rightarrow \\mathbf{MVal}$, where $\\mathbf{Loc}$ represents either a stack location or a heap location location and $\\mathbf{MVal}$ represents the symbolic value stored at that location. 3.1 Location In infer/src/bufferoverrun/absLoc.ml, Loc is defined as follows, 1234567891011121314151617181920module Allocsite = struct type t = | Unknown | Symbol of Symb.SymbolPath.partial | Known of { proc_name: string ; caller_pname: Procname.t option ; node_hash: int ; inst_num: int ; dimension: int ; represents_multiple_values: bool ; path: Symb.SymbolPath.partial option } | LiteralString of stringendmodule Loc = struct type prim = Var of Var.t | Allocsite of Allocsite.t [@@deriving compare, equal] type t = prim BoField.t [@@deriving compare, equal] ...end Allocite is defined as the location of an instruction that allocates memory. Loc has two constructors. The first one represents a variable or a register while the second one represents an allocated memory location. Specifically, $$ \\mathbf{prim} \\triangleq \\mathbf{Var}\\ |\\ \\mathbf{Allocsite}, \\mathbf{Loc} \\triangleq \\mathbf{prim}\\ |\\ \\mathbf{prim}.field\\ |\\ *\\mathbf{prim} $$ 3.2 Value","link":"/2023/02/04/Infer-Buffer-Overrun-II/"},{"title":"Infer Buffer Overrun (I) - Build and Run","text":"Abstract Hello, everyone! This is a series of blogs. I want to discuss the structure of the buffer overrun checker of infer, a static analysis tool developed by Facebook. Now, I will firstly discuss how to build it and run checkers within it. 1. How to build infer? The official document both offers methods to get binary version and directly build from source codes. Building from source codes is a time-consuming job. So if you do not need to modify the source codes, you could just install the binary relases. 1.1 Get the binary version On Macos, $ brew install infer On Linux, to install infer with VERSION=0.XX.Y, $ VERSION=0.XX.Y; \\ curl -sSL &quot;https://github.com/facebook/infer/releases/download/v$VERSION/infer-linux64-v$VERSION.tar.xz&quot; \\ | sudo tar -C /opt -xJ &amp;&amp; \\ sudo ln -s &quot;/opt/infer-linux64-v$VERSION/bin/infer&quot; /usr/local/bin/infer 1.2 Build from source codes I have tried to build infer on arm based macos. Unfortunately, I could not build clang on M1-chip mac. Hence, I only use infer to check java codes on macos. Nevertheless, if you still would like to use infer on macos, you could choose the docker image I made. On Ubuntu, please first install the packages required. The details can be found at here. Then, follow the below steps, $ git clone https://github.com/facebook/infer.git $ cd infer $ ./build-infer.sh clang # Compile cpp $ sudo make install # ...or, alternatively, install Infer into your PATH $ export PATH=`pwd`/infer/bin:$PATH Note that, infer will default build a java version. Hence, if you do not want to build the cpp version, just replace the third command with ./build-infer.sh. The common error I met is â€˜fail to ldâ€™ and â€˜not enough space on the diskâ€™. The reasons and solutions are as follows: The first one is because clang is compiled in parallel. Hence, it would produce many intermediate files, making the swap and memory full. To avoid parallel compilation or reduce the number of threads, you could change the value of JOBS to 1 in the script facebook-clang-plugins/clang/setup.sh. The second one is because you may repeatly build infer several times. Therefore, there will be several unbuilt clang within /tmp/. You could just delete the previous files or restart your machine. On Macos, to build java-based infer, first install the required packaegs. $ brew install autoconf automake cmake opam pkg-config sqlite gmp mpfr java Then, follow the same steps as Linux. 2. Usage of Infer As the official document said, there are two phases of infer: capture and analyze. Within the first phase, infer compiles the source files and generates some temporary files for further analysis. All the intermediate files are stored in the directory infer-out/. After that, infer takes the files within infer-out/ as input and then, analyzes them and report errors. 2.1 How to run infer? For instance, to analyze a cpp source file hello.cpp, $ infer capture -- clang hello.cpp $ infer analyze -- clang hello.cpp # ... or, alternatively, just run the following command instead of the above two $ infer run -- clang hello.cpp If you do not specify checkers within the above command, infer will only do some basic checks. To activate some particular checkers, please add specific option, like --bufferoverrun (checking whether there exists a buffer ovrrun bug), --cost (computing the time complexity of functions and methods), etc. 2.2 How to find the trace triggering bugs? Infer collects the trace that triggers a bug. To see the trace, just run infer explore after running the command within 2.1 and write the number of issue. $ infer explore 1 # 1 can be replaced by other issue number 2.3 Tips for debugging Infer offers a convenient analysis framework for programmers to develop multiple checkers. It uses the technique of abstract interpretations, in which there is an abstract domain, and the checker computes the abstract value before and after running each instruction. A direct way to debug infer is to print the abstract values to the console. We can observe that, within most modules, there is a function called pp. This function specifies the format for printing this data structure. To print it, please plug this function as an argument to Logging.debug_dev. For example, if instr is a variable with type Sil.instr, to print it, just insert the following code into the source codes 1Logging.debug_dev &quot;Instr: %a&quot; Sil.instr.pp instr","link":"/2023/02/04/Infer-Buffer-Overrun-I/"},{"title":"Hello World","text":"Welcome to my website! This is your very first post.","link":"/2023/02/03/hello-world/"}],"tags":[{"name":"infer","slug":"infer","link":"/tags/infer/"},{"name":"static analysis","slug":"static-analysis","link":"/tags/static-analysis/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"Static Analysis","slug":"Static-Analysis","link":"/tags/Static-Analysis/"},{"name":"Paper Reading","slug":"Paper-Reading","link":"/tags/Paper-Reading/"},{"name":"Program Analysis","slug":"Program-Analysis","link":"/tags/Program-Analysis/"},{"name":"SSA","slug":"SSA","link":"/tags/SSA/"}],"categories":[{"name":"static anlysis","slug":"static-anlysis","link":"/categories/static-anlysis/"},{"name":"Static Analysis","slug":"Static-Analysis","link":"/categories/Static-Analysis/"},{"name":"Program Analysis","slug":"Program-Analysis","link":"/categories/Program-Analysis/"}],"pages":[{"title":"","text":"Conference Paper Fair Division with Allocatorâ€™s Preference [WINEâ€™2023] [ğŸ“„] Xiaolin Bu, Zihao Li, Shengxin Liu*, Jiaxin Song, Biaoshuai Tao (alphabetical author ordering). Fair Division with Prioritized Agents [AAAIâ€™2023] [ğŸ“„] [bib] Xiaolin Bu, Zihao Li, Shengxin Liu*, Jiaxin Song, Biaoshuai Tao (alphabetical author ordering). Scalable Linear Invariant Generation with Farkasâ€™ Lemma [OOPSLAâ€™2022] [ğŸ“„] Hongming Liu, Hongfei Fu*, Zhiyong Yu, Jiaxin Song, Guoqiang Li. Journal On Existence of Truthful Fair Cake Cutting Mechanisms [Artifical Intelligence Journal] [ğŸ“„] Xiaolin Bu, Jiaxin Song, Biaoshuai Tao (alphabetical author ordering). Working Papers On the Complexity of Maximizing Social Welfare within Fair Allocations of Indivisible Goods [ğŸ“„] Xiaolin Bu, Zihao Li, Shengxin Liu*, Jiaxin Song, Biaoshuai Tao (alphabetical author ordering). Towards Denotational-semantics-based Compiler Correctness Verification Jiaxin Song, Zhang Cheng, Qinxiang Cao*.","link":"/publications/index.html"},{"title":"About","text":"I am currently a Ph.D. student at Hong Kong University of Science and Technology (HKUST), under the guidance of Prof.Charles Zhang. Before that, I received my bachelorâ€™s degree in computer science from Shanghai Jiao Tong University. During my undergraduate study, I worked closely with Biaoshuai Tao, Hongfei Fu, Qinxiang Cao and Yuhao Zhang. Thanks for these professorsâ€™ patient guidance. Teaching Assistant Algorithm Design and Analysis (SJTU), 2022 Spring. Linear and Convex Optimization (SJTU), 2022 Fall. Research Interests My research interests include program static analysis and theoretical computer science problems. More recenltly, I have been studying problems in: Compilation Optimization GPGPU Online Fair Division In 2022 summer, we organized a paper reading group for discussing recent algorithm papers. The web page is here. If you have similar research interests to me, please donâ€™t be shy to contact me. Awards Zhiyuan Honor Scholarship, SJTU (2019 - 2022, Â¥5k/year) Huatai Scholarship, SJTU (2022, Â¥1w/year) Class B Scholarship, SJTU (2021, 2022, Â¥1k/year) Class C Scholarship, SJTU (2020, Â¥500/year) Chenhao Alumni Scholarship, SJTU (2021, Â¥5k/year) Contact mail: sjtu_xiaosong@sjtu.edu.cn","link":"/about/index.html"}]}